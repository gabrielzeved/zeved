---
date: '2024-05-23'
title: Developing a code generator
description: Exploring the strength of code generation to help us automate manual tasks during development.
image: /code-generator.webp
categories:
  - flutter
  - code generation
  - dart
published: true
---

One day I heard that the laziest developers are the most valuable ones. This take can be harsh for someone to hear, but it stuck with me, and I'll explain. Lazy developers usually try to maximize their time as much as possible, and because of that, they'll try to automate everything they can to avoid losing time with manual and repetitive tasks. With these automations, they can increase not only their own productivity but their entire team's as well.

![illustration of sloth](https://miro.medium.com/v2/resize:fit:320/1*47rm5iMTsCeN6wmcsVOfIg.jpeg)

Some time ago, I found myself in a similar situation. I was doing a lot of manual work that I knew could be automated, and it annoyed me so much that I started searching for a way to fix it so i could spend my time more productively (spending time to save time—what a paradox.).

Here is the context:

I was working with [Flutter] to develop a mobile ecommerce application, in this application we use a self made content management system that requires the widget to specify a [json-schema] so that is possible to retrieve the fields and types that this widget requires.

Additionally we have to send the JSON serialized object to the content management system, but [Flutter] is a framework built using [Dart] as its programming language to develop applications and this language doesn't have a built-in way to serialize objects to JSON, so this needs to be handled by the developer. Typically, this is done in one of two ways:

- Manual serialization
- Automated serialization using code generation

So, for each widget that we needed control by this system we needed to specify:

- a schema class for any props to the widget
- a [json-schema] describing each field and types
- a json encoder/decoder
- the widget itself

You can see this widget as an example:

```dart
@JsonSerializable()
class CMSImageSchema {
  final String imageUrl;
  final double? width;
  final double? height;

  CMSImageSchema({
    required this.imageUrl,
    this.width,
    this.height,
  });

  @override
  Map<String, dynamic> schema(BuildContext context) {
    return {
      "type": "object",
      "title": "Imagem",
      "properties": {
        "imageUrl": {
          "type": "string",
          "title": "Imagem",
        },
        "width": {
          "type": "number",
          "title": "Largura da imagem",
          "description":
              "Valor em px (caso vazio preencherá o máximo possível)",
        },
        "height": {
          "type": "number",
          "title": "Altura da imagem",
          "description":
              "Valor em px (caso vazio preencherá o máximo possível)",
        },
      }
    };
  }

    @override
  Map<String, dynamic> toJson() => _$CMSImageSchemaToJson(this);

  factory CMSImageSchema.fromJson(Map<String, dynamic> json) =>
      _$CMSImageSchemaFromJson(json);
}

class CMSImage extends StatelessWidget {
  final CMSImageSchema content;

  const CMSImage({
    super.key,
    required this.content,
  });

  @override
  Widget build(BuildContext context) {
    return Image(
      imageUrl: content.imageUrl,
      height: content.height,
      width: content.width,
    );
  }
}
```

Have in mind that this is a really small widget made just for this example and with just this small example you can see how much we have to define and write for a single widget, now scale this for dozens widgets.

It became a nightmare for lazy developers.

![monkey throwing computer from the table](https://media1.tenor.com/m/nF-l7JPQ3cIAAAAC/baboon-laptop.gif)

So as you can see in the example we use something called [json-serializable] to generate functions to encode/decode objects to json, and this is made by code generation. A code generated by this library looks like this:

```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'cms_image.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

CMSImageSchema _$CMSImageSchemaFromJson(Map<String, dynamic> json) =>
    CMSImageSchema(
      imageUrl: json['imageUrl'] as String,
      width: (json['width'] as num?)?.toDouble(),
      height: (json['height'] as num?)?.toDouble(),
    );

Map<String, dynamic> _$CMSImageSchemaToJson(CMSImageSchema instance) {
  final val = <String, dynamic>{
    'imageUrl': instance.imageUrl,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('width', instance.width);
  writeNotNull('height', instance.height);
  return val;
}
```

With that we can see that is possible to generate code for a class using their the types and fields, the same way that [json-serializable] did. So our goal is to make a similar tool but for generating [json-schema].

So, how [json-serializable] works?

This library uses a native dart tool called [build] that provides libraries and interfaces to generate code for dart files. This tool have many helper classes that we can use, but we'll be focusing in using the `SimpleElementVisitor` and `GeneratorForAnnotation` classes.

So, before we enter in any kind of code explanation, let's architect what is our goal.

So a [json-schema] is a json that not only describe a type of something but it can add extra metadata, like `title` and `description`. So it would be perfect to have something like [json-serializable] annotations but with the possibility to add those metadata if necessary and all the rest could be extracted from the dart types.

Something like this:

```dart
@JsonSerializable()
@SchemaSerializable(title: "My image", description: "This is my custom schema")
class CMSImageSchema {
  @SchemaValue(title: "Image URL")
  final String imageUrl;
  @SchemaValue(title: "Width")
  final double? width;
  @SchemaValue(title: "Height")
  final double? height;

  CMSImageSchema({
    required this.imageUrl,
    this.width,
    this.height,
  });
}
```

## So, let's get started.

This first step to create a generator is to create an annotation class that we will use to mark all classes that will go through our generator, and inside the annotation all the custom properties that we want to provide to the developer.

So, for this one it turned out like this:

```dart
class SchemaSerializable {
  final String? title;
  final String? description;

  const SchemaSerializable({
    this.title,
    this.description,
  });
}
```

Now we have to define a builder class that will be responsible to find each class annotaded with `SchemaSerializable` and produce a custom code. For this we will use the class `GeneratorForAnnotation`. This class has the following structure:

```dart
Builder build(BuilderOptions options) {
  return SharedPartBuilder([SchemaBuilder()], 'schema_builder');
}

class SchemaBuilder extends GeneratorForAnnotation<SchemaSerializable> {
  @override
  FutureOr<String> generateForAnnotatedElement(
    Element element,
    ConstantReader annotation,
    BuildStep buildStep,
  ) async {
    // Implement code generation login
  }
}
```

This `build` function is the entry point for the `build_runner`, you have to provide your `GeneratorForAnnotation` extended class and a name for your generator that will be required inside the `build.yml` file.

Inside the `generateForAnnotatedElement` we have access to the following variables:

- `element`: DartElement that have the annotation
- `annotation`: Object that allow us to read properties defined inside the annotation
- `buildStep`: Helper to read and write assets. We will not use for this example.

and the function expects a `String` as return, and this `String` will be the code that will be written in the generated file.

so with all that we created until now we can create a simple generator that build a [json-schema] that have only the `title` and `description` defined by the developer.

```dart
class SchemaBuilder extends GeneratorForAnnotation<SchemaSerializable> {
  @override
  FutureOr<String> generateForAnnotatedElement(
    Element element,
    ConstantReader annotation,
    BuildStep buildStep,
  ) async {
    String title = annotation.read('title').stringValue;
    String description = annotation.read('description').stringValue;

    return '''
  Map<String, dynamic> _\$${element.name}Schema = {
    "type": "object",
    "title": "$title",
    "description: "$description"
  }
    ''';
  }
}
```

### Testing our progress

In order to test our code we will have register our brand new builder, and to do this we have to create a `build.yml` file in the root of the project. You can see all properties for this configuration file [here](https://github.com/dart-lang/build/blob/master/docs/build_yaml_format.md)

```yaml
builders:
  schema_builder:
    import: 'package:schema_builder/builder.dart'
    builder_factories: ['build']
    build_extensions: { '.dart': ['.schema_builder.g.part'] }
    auto_apply: dependents
    build_to: cache
    applies_builders: ['source_gen|combining_builder']
```

_the `import` field must be the path to the file that contains a class that extends `GeneratorForAnnotation`_

and an example class to test our builder:

```dart
part 'example.g.dart';

@SchemaSerializable(title: "My example", description: "This is my custom schema")
class Example {
  final String stringExample;

  Example({
    required this.imageUrl,
    this.width,
    this.height,
  });
}
```

and run `dart run build_runner build`

![tada](https://media1.tenor.com/m/D5g2GDCx9WwAAAAd/fortnite-star-wars.gif)

```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'example.dart';

// **************************************************************************
// Generator: SchemaBuilder
// **************************************************************************

Map<String, dynamic> _$ExampleSchema = {
  "type": "object",
  "title": "My example",
  "description": "This is my custom schema",
};
```

and this is our first generated code.

The next step is to parse the fields into the schema, but before that let's refactor somethings.

### Parsing json-schema

The problem with the current implementation is that when we extract the values from the annotation with the `annotation.read('field').stringValue` it can crash if the value is null. So to fix that we can just check if the value is not null with `annotation.read('field').isNull` and add to the map, but with the following features that we'll implement it can became harder and harder to maintain with this approach, so let's build a helper class to manage our [json-schema] result.

```dart
class SchemaBuffer {
  Map<String, dynamic> schema = {};

  void type(String type) {
    schema['"type"'] = '"$type"';
  }

  void title(String type) {
    schema['"title"'] = '"$type"';
  }

  void description(String type) {
    schema['"description"'] = '"$type"';
  }
}
```

and after refactoring:

```dart
class SchemaBuilder extends GeneratorForAnnotation<SchemaSerializable> {
  @override
  FutureOr<String> generateForAnnotatedElement(
    Element element,
    ConstantReader annotation,
    BuildStep buildStep,
  ) async {
    SchemaBuffer schemaBuffer = SchemaBuffer();
    schemaBuffer.type("object");

    ConstantReader title = annotation.read('title');
    ConstantReader description = annotation.read('description');

    if (!title.isNull) {
      schemaBuffer.title(title.stringValue);
    }

    if (!description.isNull) {
      schemaBuffer.description(description.stringValue);
    }

    return '''
  Map<String, dynamic> _\$${element.name}Schema = ${schemaBuffer.schema.toString()};
    ''';
  }
}
```

### Parsing primitive types

The `SimpleElementVisitor` will help us with this task to map all fields from a class.

First we need a way to map types from [Dart] to [json-schema]. For this example we will handle only the primitive types, so:

```dart
final Map<String, String> jsonTypes = {
  "String": "string",
  "int": "number",
  "double": "number",
  "bool": "boolean"
};
```

The `SimpleElementVisitor` provide us many functions that give us access to elements from the code that we are handling, in this case we will only need the `visitFieldElement` that is self explanatory, but keep in mind that if you need that is a lot more that can be used.

So our visitor can be like this:

```dart
class SchemaVisitor extends SimpleElementVisitor<void> {
  Map<String, SchemaBuffer> fields = {};

  @override
  void visitFieldElement(FieldElement element) {
    SchemaBuffer buffer = SchemaBuffer();

    String jsonType =
        jsonTypes[element.type.getDisplayString(withNullability: false)]!;

    buffer.type(jsonType);
    fields[element.name] = buffer;
  }
}
```

now we have one `SchemaBuffer` for each field describing it's type and metadata, so to add that to the main buffer we need to create a new function inside our `SchemaBuffer`.

```dart
class SchemaBuffer {
  //... Previous functions

  void property(String field, SchemaBuffer buffer) {
    schema['"properties"'] ??= {};
    schema['"properties"']['"$field"'] = buffer.schema;
  }
}

```

and with all of that we can add this to our `builder`:

```dart
FutureOr<String> generateForAnnotatedElement(
  Element element,
  ConstantReader annotation,
  BuildStep buildStep,
) async {
  SchemaVisitor visitor = SchemaVisitor();
  element.visitChildren(visitor);

  //... remain the same

  for (MapEntry<String, SchemaBuffer> entry in visitor.fields.entries) {
    schemaBuffer.property(entry.key, entry.value);
  }

  return '''
Map<String, dynamic> _\$${element.name}Schema = ${schemaBuffer.schema.toString()};
  ''';
}
```

now this is our result:

```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'example.dart';

// **************************************************************************
// Generator: SchemaBuilder
// **************************************************************************

Map<String, dynamic> _$ExampleSchema = {
  "title": "My example",
  "description": "This is my custom schema",
  "properties": {
    "stringExample": {"type": "string"}
  }
};
```

## Conclusion

Developing a code generator can really boost productivity by automating those repetitive tasks we all dread. By creating a custom code generator to produce JSON schemas from Dart classes in Flutter, we can streamline defining and serializing widget properties. This not only saves time but also cuts down on potential errors, leading to more consistent and maintainable code.

This example shows a straightforward way to develop a code generator for automating JSON schema generation in Flutter. While it’s a simple implementation, it lays the groundwork for more complex automation tasks. If you're interested in diving deeper or want to contribute, you can check out my public package [schema-serializable] on GitHub.

Contributions, feedback, and suggestions are always welcome.

<!-- Links -->

[schema-serializable]: https://github.com/
[Flutter]: https://flutter.dev/
[Dart]: https://dart.dev/
[json-schema]: https://json-schema.org/
[json-serializable]: https://pub.dev/packages/json_serializable
[build]: https://github.com/dart-lang/build
